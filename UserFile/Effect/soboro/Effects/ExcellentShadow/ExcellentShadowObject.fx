////////////////////////////////////////////////////////////////////////////////////////////////
//
//  ExcellentShadowObject
//  作成: そぼろ
//
////////////////////////////////////////////////////////////////////////////////////////////////


#include "ExcellentShadowCommonSystem.fx"


//アクセサリに法線を使った陰影をつけるか
#define UNTOON_NORMALSHADOW 1


////////////////////////////////////////////////////////////////////////////////////////////////
// パラメータ宣言


// 座法変換行列
float4x4 WorldViewProjMatrix      : WORLDVIEWPROJECTION;
float4x4 WorldMatrix              : WORLD;
float4x4 ViewMatrix               : VIEW;
float4x4 LightWorldViewProjMatrix : WORLDVIEWPROJECTION < string Object = "Light"; >;

float3   LightDirection    : DIRECTION < string Object = "Light"; >;
float3   CameraPosition    : POSITION  < string Object = "Camera"; >;

// マテリアル色
float4   MaterialDiffuse   : DIFFUSE  < string Object = "Geometry"; >;
float3   MaterialAmbient   : AMBIENT  < string Object = "Geometry"; >;
float3   MaterialEmmisive  : EMISSIVE < string Object = "Geometry"; >;
float3   MaterialSpecular  : SPECULAR < string Object = "Geometry"; >;
float    SpecularPower     : SPECULARPOWER < string Object = "Geometry"; >;
float3   MaterialToon      : TOONCOLOR;
float4   EdgeColor         : EDGECOLOR;
// ライト色
float3   LightDiffuse      : DIFFUSE   < string Object = "Light"; >;
float3   LightAmbient      : AMBIENT   < string Object = "Light"; >;
float3   LightSpecular     : SPECULAR  < string Object = "Light"; >;
static float4 DiffuseColor  = MaterialDiffuse  * float4(LightDiffuse, 1.0f);
static float3 AmbientColor  = min(1, MaterialAmbient * LightAmbient + MaterialEmmisive);
static float3 SpecularColor = MaterialSpecular * LightSpecular;

bool     parthf;   // パースペクティブフラグ
bool     transp;   // 半透明フラグ
bool     spadd;    // スフィアマップ加算合成フラグ
#define SKII1    1500
#define SKII2    8000
#define Toon     3

// オブジェクトのテクスチャ
texture ObjectTexture: MATERIALTEXTURE;
sampler ObjTexSampler = sampler_state {
    texture = <ObjectTexture>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = LINEAR;
    MAXANISOTROPY = 16;
};

// スフィアマップのテクスチャ
texture ObjectSphereMap: MATERIALSPHEREMAP;
sampler ObjSphareSampler = sampler_state {
    texture = <ObjectSphereMap>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = LINEAR;
    MAXANISOTROPY = 16;
};

// MMD本来のsamplerを上書きしないための記述です。削除不可。
sampler MMDSamp0 : register(s0);
sampler MMDSamp1 : register(s1);
sampler MMDSamp2 : register(s2);



////////////////////////////////////////////////////////////////////////////////////////////////

shared texture ExcellentShadowZMap : OFFSCREENRENDERTARGET;

sampler ExcellentShadowZMapSampler = sampler_state {
    texture = <ExcellentShadowZMap>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = NONE;
    AddressU  = CLAMP;
    AddressV = CLAMP;
};

shared texture ExcellentShadowZMapFar : OFFSCREENRENDERTARGET;

sampler ExcellentShadowZMapFarSampler = sampler_state {
    texture = <ExcellentShadowZMapFar>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = NONE;
    AddressU  = CLAMP;
    AddressV = CLAMP;
};

////////////////////////////////////////////////////////////////////////////////////////////////
// 輪郭描画

// 頂点シェーダ
float4 ColorRender_VS(float4 Pos : POSITION) : POSITION 
{
    // カメラ視点のワールドビュー射影変換
    float4 Out = mul( Pos, WorldViewProjMatrix );
    
    return Out;
}

// ピクセルシェーダ
float4 ColorRender_PS() : COLOR
{
    // 輪郭色で塗りつぶし
    return EdgeColor;
}

// 輪郭描画用テクニック
technique EdgeTec < string MMDPass = "edge"; > {
    /*pass DrawEdge {
        AlphaBlendEnable = FALSE;
        AlphaTestEnable  = FALSE;
        
        VertexShader = compile vs_2_0 ColorRender_VS();
        PixelShader  = compile ps_2_0 ColorRender_PS();
    }*/
}


///////////////////////////////////////////////////////////////////////////////////////////////
// 影（非セルフシャドウ）描画

// 影描画用テクニック
technique ShadowTec < string MMDPass = "shadow"; > {
    
}

///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画（セルフシャドウOFF）

// オブジェクト描画用テクニック
technique MainTec0 < string MMDPass = "object";  > {
    
}

///////////////////////////////////////////////////////////////////////////////////////////////
// セルフシャドウ用Z値プロット

struct VS_ZValuePlot_OUTPUT {
    float4 Pos : POSITION;              // 射影変換座標
    float4 ShadowMapTex : TEXCOORD0;    // Zバッファテクスチャ
};

// 頂点シェーダ
VS_ZValuePlot_OUTPUT ZValuePlot_VS( float4 Pos : POSITION )
{
    VS_ZValuePlot_OUTPUT Out = (VS_ZValuePlot_OUTPUT)0;
    
    // ライトの目線によるワールドビュー射影変換をする
    Out.Pos = mul( Pos, LightWorldViewProjMatrix );
    
    // テクスチャ座標を頂点に合わせる
    Out.ShadowMapTex = Out.Pos;
    
    //Out.Pos.z *= 0.1;
    //Out.Pos.z += 0.1;
    
    return Out;
}

// ピクセルシェーダ
float4 ZValuePlot_PS( float4 ShadowMapTex : TEXCOORD0 ) : COLOR
{
    float depth = ShadowMapTex.z/ShadowMapTex.w;
    
    // R色成分にZ値を記録する
    return float4(depth, 0, 0, 1);
}

// Z値プロット用テクニック
technique ZplotTec < string MMDPass = "zplot"; > {
    pass ZValuePlot {
        AlphaBlendEnable = FALSE;
        VertexShader = compile vs_2_0 ZValuePlot_VS();
        PixelShader  = compile ps_2_0 ZValuePlot_PS();
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画（セルフシャドウON）

// シャドウバッファのサンプラ。"register(s0)"なのはMMDがs0を使っているから
sampler DefSampler : register(s0);

struct BufferShadow_OUTPUT {
    float4 Pos       : POSITION;     // 射影変換座標
    float4 ZCalcTex  : TEXCOORD0;    // Z値
    float2 Tex       : TEXCOORD1;    // テクスチャ
    float3 Normal    : TEXCOORD2;    // 法線
    float3 Eye       : TEXCOORD3;    // カメラとの相対位置
    float4 IZCalcTex : TEXCOORD4;     // スフィアマップテクスチャ座標
    
    float4 ScreenPos : TEXCOORD5;
    
};

// 頂点シェーダ
BufferShadow_OUTPUT BufferShadow_VS(MMM_SKINNING_INPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon)
{
    BufferShadow_OUTPUT Out = (BufferShadow_OUTPUT)0;
    
    float4 pos = GETPOS;
    
    // カメラ視点のワールドビュー射影変換
    Out.Pos = mul( pos, WorldViewProjMatrix );
    
    Out.ScreenPos = Out.Pos;
    
    Out.Normal = normalize( mul( IN.Normal, (float3x3)WorldMatrix ) );
    // ライト視点によるワールドビュー射影変換
    Out.ZCalcTex = mul( pos, LightWorldViewProjMatrix );
    Out.IZCalcTex = mul( pos, InternalLightWorldViewProjMatrix );
    
    // テクスチャ座標
    Out.Tex = IN.Tex;
    
    return Out;
}

// ピクセルシェーダ
float4 BufferShadow_PS(BufferShadow_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon) : COLOR
{
    // スペキュラ色計算
    float3 HalfVector = normalize( normalize(IN.Eye) + -LightDirection );
    float3 Specular = pow( max(0,dot( HalfVector, normalize(IN.Normal) )), SpecularPower ) * SpecularColor;
    
    float4 Color = float4(1,1,1,1);
    
    float Alpha = DiffuseColor.a;
    float ShadowRate = 1;
    float ShadowBlurStrength = 0;
    
    float Z1 = IN.ScreenPos.w;
    
    if ( useTexture ) {
        // テクスチャ適用
        float4 TexColor = tex2D( ObjTexSampler, IN.Tex );
        Alpha *= TexColor.a;
        
    }
    
    
    
    ///////////////////////////////////////////////////////////////////////
    //シャドウシステム
    
    // テクスチャ座標に変換
    IN.IZCalcTex.xyz /= IN.IZCalcTex.w;
    float2 TransTexCoord1 = 0.5 + IN.IZCalcTex.xy * float2(0.5, -0.5);
    float2 TransTexCoord2 = 0.5 + (IN.IZCalcTex.xy / SIZERATE_FAR) * float2(0.5, -0.5);
    
    float farfade = saturate(5 * (1 - length(IN.IZCalcTex.xy / SIZERATE_FAR)));
    
    if(!any( saturate(TransTexCoord2) != TransTexCoord2 ) ) { 
        float comp;
        
        float mixrate = saturate((length(IN.IZCalcTex.xy) - 0.8) / (1 - 0.8));
        
        float depth = tex2D(ExcellentShadowZMapSampler,TransTexCoord1).r;
        float depth2 = tex2D(ExcellentShadowZMapFarSampler,TransTexCoord2).r;
        
        depth = lerp(depth, depth2, mixrate);
        
        float dist = IN.IZCalcTex.z - depth;
        
        //comp = 1 - saturate(max(dist, 0.0f) * 20000 / (1 + mixrate * 3) - 0.05);
        comp = 1 - saturate(max(dist, 0.0f) * 20000 * size1 / (1 + mixrate * 3) - 0.05 * sqrt(size1));
        
        comp = lerp(1, comp, farfade);
        
        ShadowBlurStrength = max(0, dist) * 300 / sqrt(size1);
        ShadowRate = comp;
    }
    
    
    #ifndef MIKUMIKUMOVING
    
    // テクスチャ座標に変換
    IN.ZCalcTex /= IN.ZCalcTex.w;
    float2 TransTexCoord0;
    TransTexCoord0.x = (1.0f + IN.ZCalcTex.x)*0.5f;
    TransTexCoord0.y = (1.0f - IN.ZCalcTex.y)*0.5f;
    
    if( !any( saturate(TransTexCoord0) != TransTexCoord0 ) && IN.ZCalcTex.z <= 1) {
        
        float comp;
        
        float dist = IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord0).r;
        
        float mixrate = saturate(4 * (1 - length(IN.ZCalcTex.xy)));
        
        if(parthf) {
            // セルフシャドウ mode2
            comp=1-saturate(max(dist , 0.0f)*SKII2*TransTexCoord0.y-0.3f);
        } else {
            // セルフシャドウ mode1
            comp=1-saturate(max(dist , 0.0f)*SKII1-0.3f);
        }
        
        
        float mix1 = lerp(ShadowRate, comp, mixrate);
        float mix2 = min(ShadowRate, lerp(1, comp, mixrate));
        
        ShadowRate = lerp(mix1, mix2, saturate(ShadowBlurStrength * 6));
        
    }
    
    #endif
    
    
    if ( useToon ) ShadowRate = min(ShadowRate, saturate(dot(IN.Normal,-LightDirection)*Toon));
    #if UNTOON_NORMALSHADOW==1
    //else           ShadowRate = min(ShadowRate, saturate(dot(IN.Normal,-LightDirection)*Toon));
    #endif
    
    
    Color.r = ShadowRate;
    Color.g = Z1;
    Color.b = ShadowBlurStrength;
    Color.a = Alpha;
    
    if(Alpha < 0.9) Color.a = 0;
    
    return Color;
}

// オブジェクト描画用テクニック（アクセサリ用）
technique MainTecBS0  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, false, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, false, false);
    }
}

technique MainTecBS1  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, false, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, false, false);
    }
}

technique MainTecBS2  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, true, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, true, false);
    }
}

technique MainTecBS3  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, true, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, true, false);
    }
}

// オブジェクト描画用テクニック（PMDモデル用）
technique MainTecBS4  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, false, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, false, true);
    }
}

technique MainTecBS5  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, false, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, false, true);
    }
}

technique MainTecBS6  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, true, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, true, true);
    }
}

technique MainTecBS7  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, true, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, true, true);
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////
