////////////////////////////////////////////////////////////////////////////////////////////////
//
//  WF_Object.fxsub モデルを地面に対して鏡像描画
//  ( WorkingFloorX.fx から呼び出されます．オフスクリーン描画用)
//  作成: 針金P( 舞力介入P氏のfull.fx改変 )
//
////////////////////////////////////////////////////////////////////////////////////////////////

float3 MirrorPos = float3( 0.0, 0.0, 0.0 );    // ローカル座標系における鏡面上の任意の座標(アクセ頂点座標の一点)
float3 MirrorNormal = float3( 0.0, 1.0, 0.0 ); // ローカル座標系における鏡面の法線ベクトル

//------------------------------------------------------------------
// ikPaper用の設定


// パネルの中心となるアクセサリ名
// モデル自身の場合は(self)を指定する。アクセサリなどの場合は、.xなど拡張子まで指定する。
#define	PanelObjectName		"(self)"
// パネルの中心となるボーン名
// ボーンが不要な場合は、#defineの前に//を入れてコメントアウトする。
//#define	PanelBoneName		"センター"
#define	PanelBoneName		"上半身"

// ダミー親
// モデルの挙動とは別にパネルを動かしたい場合用。
// 使用しない場合は、ParentObjectName の行頭に//を入れる。
#define	ParentObjectName		"dummyParent.pmx"
#define	ParentBoneName			"ボーン01"


// パネルの余白部分の色
float3 PanelColor = float3(1.0,1.0,1.0);
float3 PanelShadowColor = float3(1.0,1.0,1.0) * 0.8; // 影の濃さ
float3 PanelAmbient = float3(1.0,1.0,1.0) * 0.4; // ライトが(0,0,0)のときの明るさ

// パネル全体のスペキュラ
float PanelSpecularPower = 32.0;
float3 PanelSpecularColor = float3(1.0,1.0,1.0);

// パネルの余白。1.0 = 1MMD ≒ 10cm
float	PanelMargin = 0.4;
// パネルのエッジサイズ。
float	PanelThickness = 0.03;
// パネルの深度をいじる量。
float	PanelDepthOffset = 0.5;

// 厚みを潰す率。
// 前後関係が破たんしてチラつく場合は、大きめの値にする。大きい値ほど厚みが見える
#define	SqueezeScale	0.1

// パネルの回転を倍にする。0: 1倍。1: 2倍
#define ENABLE_TWICE_ROTATION	0

// パネルの縁を描画する。0:描画しない。1:描画する。
// ※ WF用は常に縁を表示しない
#define ENABLE_DRAW_EDGE	0

// パネル内のモデルも陰影計算を行うか。0:陰影計算をしない。1:する。
// パネルとモデル両方に落ち影が出たりなど、陰影計算を行うおかしく見えることがある。
#define ENABLE_INNER_LIGHTING	1
// スフィアマップの計算も行う? 0:行わない。1:行う。
// ENABLE_INNER_LIGHTING 0の場合、常にスフィアマップを計算しない。
#define ENABLE_SPHERE_MAP		0
// モデル内のシャドウマップを有効にする。
#define ENABLE_SHADOW_MAP		0



////////////////////////////////////////////////////////////////////////////////////////////////

// NOTE: 位置と回転を独立させたい場合は、ここを改造する。
#if defined(PanelBoneName)
float3 CenterPosition : CONTROLOBJECT < string name = PanelObjectName; string item = PanelBoneName;>;
float4x4 PanelMat : CONTROLOBJECT < string name = PanelObjectName; string item = PanelBoneName; >;
#else
float3 CenterPosition : CONTROLOBJECT < string name = PanelObjectName; >;
float4x4 PanelMat : CONTROLOBJECT < string name = PanelObjectName; >;
#endif

#if defined(ParentObjectName)
#if defined(ParentBoneName)
float4x4 ParentMat : CONTROLOBJECT < string name = ParentObjectName; string item = ParentBoneName; >;
#else
float4x4 ParentMat : CONTROLOBJECT < string name = ParentObjectName; >;
#endif
inline float3 shiftParent(float3 pos)
{
	return mul(float4(pos,1), ParentMat).xyz;
}
inline float3 rotParent(float3 v)
{
	return mul(v, (float3x3)ParentMat);
}
#else
inline float3 shiftParent(float3 pos) { return pos; }
inline float3 rotParent(float3 v) { return v;}
#endif



///////////////////////////////////////////////////////////////////////////////////////////////
// 鏡面座標変換パラメータ
float4x4 MirrorWorldMatrix: CONTROLOBJECT < string Name = "(OffscreenOwner)"; >; // 鏡面アクセのワールド変換行列

// ワールド座標系における鏡像位置への変換
static float3 WldMirrorPos = mul( float4(MirrorPos, 1.0f), MirrorWorldMatrix ).xyz;
static float3 WldMirrorNormal = normalize( mul( MirrorNormal, (float3x3)MirrorWorldMatrix ) );

// 座標の鏡像変換
float4 TransMirrorPos( float4 Pos )
{
    Pos.xyz -= WldMirrorNormal * 2.0f * dot(WldMirrorNormal, Pos.xyz - WldMirrorPos);
    return Pos;
}

float3 CameraPosition : POSITION  < string Object = "Camera"; >;

// 鏡面表裏判定(座標とカメラが両方鏡面の表側にある時だけ＋)
float IsFace( float4 Pos )
{
    return min( dot(Pos.xyz-WldMirrorPos, WldMirrorNormal),
                dot(CameraPosition-WldMirrorPos, WldMirrorNormal) );
}


///////////////////////////////////////////////////////////////////////////////////////////////

// 座標変換行列
float4x4 WorldMatrix              : WORLD;
float4x4 ViewMatrix               : VIEW;
float4x4 ViewProjMatrix           : VIEWPROJECTION;
float4x4 WorldViewMatrix		: WORLDVIEW;
float4x4 InvWorldMatrix			: WORLDINVERSE;
float4x4 ProjMatrix				: PROJECTION;

float4x4 LightWorldViewProjMatrix : WORLDVIEWPROJECTION < string Object = "Light"; >;

float3 LightDirection : DIRECTION < string Object = "Light"; >;

// マテリアル色
float4 MaterialDiffuse   : DIFFUSE  < string Object = "Geometry"; >;
float3 MaterialAmbient   : AMBIENT  < string Object = "Geometry"; >;
float3 MaterialEmmisive  : EMISSIVE < string Object = "Geometry"; >;
float3 MaterialSpecular  : SPECULAR < string Object = "Geometry"; >;
float  SpecularPower     : SPECULARPOWER < string Object = "Geometry"; >;
float3 MaterialToon      : TOONCOLOR;
float4 EdgeColor         : EDGECOLOR;
float4 GroundShadowColor : GROUNDSHADOWCOLOR;
// ライト色
float3 LightDiffuse   : DIFFUSE   < string Object = "Light"; >;
float3 LightAmbient   : AMBIENT   < string Object = "Light"; >;
float3 LightSpecular  : SPECULAR  < string Object = "Light"; >;
static float4 DiffuseColor	= MaterialDiffuse  * float4(max(LightDiffuse, 0), 1.0f);
static float3 AmbientColor	= saturate(MaterialAmbient * LightAmbient + MaterialEmmisive);
static float3 SpecularColor	= PanelSpecularColor * LightSpecular;
static float3 PanelLightColor = saturate(PanelAmbient + LightSpecular);
static float3 SpecularColor2 = MaterialSpecular * LightSpecular;

// テクスチャ材質モーフ値
float4 TextureAddValue  : ADDINGTEXTURE;
float4 TextureMulValue  : MULTIPLYINGTEXTURE;
float4 SphereAddValue   : ADDINGSPHERETEXTURE;
float4 SphereMulValue   : MULTIPLYINGSPHERETEXTURE;

bool	use_texture;		//	テクスチャフラグ
bool	use_spheremap;		//	スフィアフラグ
bool	use_toon;			//	トゥーンフラグ
bool	use_subtexture;		// サブテクスチャフラグ

bool parthf;   // パースペクティブフラグ
bool transp;   // 半透明フラグ
bool spadd;    // スフィアマップ加算合成フラグ
#define SKII1  1500
#define SKII2  8000
#define Toon   3


// オブジェクトのテクスチャ
texture ObjectTexture: MATERIALTEXTURE;
sampler ObjTexSampler = sampler_state {
    texture = <ObjectTexture>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
    MIPFILTER = LINEAR;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
};

// スフィアマップのテクスチャ
texture ObjectSphereMap: MATERIALSPHEREMAP;
sampler ObjSphareSampler = sampler_state {
    texture = <ObjectSphereMap>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
    MIPFILTER = LINEAR;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
};

// トゥーンマップのテクスチャ
texture ObjectToonTexture: MATERIALTOONTEXTURE;
sampler ObjToonSampler = sampler_state {
    texture = <ObjectToonTexture>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
    MIPFILTER = NONE;
    ADDRESSU  = CLAMP;
    ADDRESSV  = CLAMP;
};

// シャドウバッファのサンプラ。"register(s0)"なのはMMDがs0を使っているから
sampler DefSampler : register(s0);


////////////////////////////////////////////////////////////////////////////////////////////////
// フラット化

float3 ChoiseNormal()
{
	float3 z = normalize(PanelMat[2].xyz * float3(1,0,1));

	#if ENABLE_TWICE_ROTATION > 0
	// 2倍の角度にする
	float3 newz = 0;
	newz.z = z.z * z.z - z.x * z.x;
	newz.x = 2.0 * z.x * z.z;
	z = newz;
	#endif

	return z;
}

// モデルの向きから求めた法線
static float3 BasePanelNormal = ChoiseNormal();
// 親による回転を考慮した最終法線
static float3 PanelNormal = rotParent(BasePanelNormal);

// パネル裏面が見えている場合は法線を反転させる
inline float3 AdjustPanelNormal(float3 v)
{
	return PanelNormal * ((dot(v, PanelNormal) >= 0.0) ? 1 : -1);
}

float3x3 CalcRotMat()
{
	float3 forward = BasePanelNormal;
	float3 up = float3(0,1,0);
	float3 right = cross(up, forward);
	float3x3 mat = { right, up, forward };
	return mat;
}

static float3x3 RotMat = CalcRotMat();
float3x3 SqueezeMat = { float3(1,0,0), float3(0,1,0), float3(0,0,0)};
static float3x3 FlattenMat = mul(transpose(RotMat), mul(SqueezeMat, RotMat));

inline float3 shift(float3 pos)
{
	pos += float3(0, CenterPosition.y + PanelMargin * 0.5, 0);
	pos = shiftParent(pos);
	pos += float3(CenterPosition.x, 0, CenterPosition.z);
	return pos;
}

inline float3 flatten(float3 pos)
{
	pos = mul(pos, (float3x3)WorldMatrix);			// アクセサリ対策
	float3 newPos = mul(pos - CenterPosition, FlattenMat);
	newPos = shift(newPos);
	newPos = mul(newPos, (float3x3)InvWorldMatrix);	// アクセサリ対策
	return newPos;
}

// 枠用の処理:法線方向に広げる
inline float3 wideflatten(float3 pos, float3 normal, float margin)
{
	pos = mul(pos, (float3x3)WorldMatrix);			// アクセサリ対策
	// 法線方向に膨らませる
	pos += normal * margin;
	float3 newPos = mul(pos - CenterPosition, FlattenMat);
	newPos = shift(newPos);
	newPos = mul(newPos, (float3x3)InvWorldMatrix);	// アクセサリ対策
	return newPos;
}

// 射影変換: z軸を調整する。
float4 CalcModelProjPosition(float4 pos, float3 wpos, float3 v)
{
	// 鏡像化
	float4 wpos0 = mul( pos, WorldMatrix );
	wpos0 = TransMirrorPos( wpos0 ); // 鏡像変換
	float4 pposFlat = mul( wpos0, ViewProjMatrix );
	pposFlat.x = -pposFlat.x; // ポリゴンが裏返らないように左右反転にして描画

	// MEMO: wposも鏡像変換する？

	float z = mul(wpos - CenterPosition, transpose(RotMat)).z;
	// 裏が見えている場合はzを反転させる
	z *= ((dot(v, PanelNormal) < 0.0) ? 1 : -1);
	float offset = z * SqueezeScale - PanelDepthOffset;

	// zを手前にする
	float4 vpos = mul( pos, WorldViewMatrix );
	vpos.z += offset;
	float4 ppos = mul( vpos, ProjMatrix );
	pposFlat.z = ppos.z / ppos.w * pposFlat.w;

	return pposFlat;
}

// 射影変換: z軸を調整する。
float4 CalcPanelProjPosition(float4 pos, float offset)
{
	float4 wpos0 = mul( pos, WorldMatrix );
	wpos0 = TransMirrorPos( wpos0 ); // 鏡像変換
	float4 pposFlat = mul( wpos0, ViewProjMatrix );
	pposFlat.x = -pposFlat.x; // ポリゴンが裏返らないように左右反転にして描画

	// zを奥にやる
	float4 vpos = mul( pos, WorldViewMatrix );
	vpos.z += offset;
	float4 ppos = mul( vpos, ProjMatrix );
	pposFlat.z = ppos.z / ppos.w * pposFlat.w;

	return pposFlat;
}


////////////////////////////////////////////////////////////////////////////////////////////////

// 輪郭描画用テクニック
technique EdgeTec < string MMDPass = "edge"; > {}

// 影描画用テクニック
technique ShadowTec < string MMDPass = "shadow"; > {}


///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画（セルフシャドウON）

struct VS_OUTPUT {
	float4 Pos		: POSITION;		// 射影変換座標
	float4 ZCalcTex	: TEXCOORD0;	// Z値
	float4 Tex		: TEXCOORD1;	// テクスチャ + スフィアマップテクスチャ座標
	float3 Normal	: TEXCOORD2;	// 法線
	float3 Eye		: TEXCOORD3;	// カメラとの相対位置
	float4 WPos		: TEXCOORD4;	// ワールド座標

	#if ENABLE_INNER_LIGHTING > 0
	float4 ZCalcTex2	: TEXCOORD5;	// Z値
	float3 Eye2		: TEXCOORD6;	// カメラとの相対位置
	float3 Normal2	: TEXCOORD7;	// 法線
	#endif

	float4 Color	: COLOR0;		// ディフューズ色
};

// シャドウマップの計算
float CalcShadow(float4 zcalc)
{
	float comp = 1;
	// テクスチャ座標に変換
	zcalc /= zcalc.w;
	float2 TransTexCoord = zcalc.xy * float2(0.5, - 0.5) + 0.5;
	if( all( saturate(TransTexCoord) == TransTexCoord ) )
	{
		float shadow = max(zcalc.z-tex2D(DefSampler,TransTexCoord).r , 0.0f);
		float k = (parthf) ? SKII2 * TransTexCoord.y : SKII1;
		comp = 1 - saturate(shadow * k - 0.3f);
	}
	return comp;
}

// パネル内のモデル
VS_OUTPUT Object_VS(float4 Pos : POSITION, float3 Normal : NORMAL, 
	float2 Tex : TEXCOORD0, float2 Tex2 : TEXCOORD1, 
	uniform bool useTexture, uniform bool useSphereMap, 
	uniform bool useToon, uniform bool useSelfshadow)
{
	VS_OUTPUT Out = (VS_OUTPUT)0;

	float4 posOrig = Pos;
	float3 normalOrig = Normal;
	float3 wpos = mul( Pos, WorldMatrix ).xyz;
	float3 Eye = CameraPosition - wpos;

	Pos.xyz = flatten(Pos.xyz);
	Out.WPos = mul( Pos, WorldMatrix );

	Normal = AdjustPanelNormal(Eye);

	// カメラ視点のワールドビュー射影変換
	Out.Pos = CalcModelProjPosition(Pos, wpos, Eye);

	// カメラとの相対位置
	Out.Eye = normalize(CameraPosition - Out.WPos.xyz);
	// 頂点法線
	Out.Normal = Normal; // normalize( mul( Normal, (float3x3)WorldMatrix ) );

	if (useSelfshadow)
	{
		// ライト視点によるワールドビュー射影変換
		Out.ZCalcTex = mul( Pos, LightWorldViewProjMatrix );
	}

	Out.Color.rgb = max(MaterialAmbient * LightAmbient, 0) + MaterialEmmisive;
	Out.Color.a = MaterialDiffuse.a;
	if (!useToon)
	{
		Out.Color.rgb += MaterialDiffuse.rgb;
	}
	Out.Color = saturate(Out.Color);

	// テクスチャ座標
	Out.Tex.xy = Tex.xy;

	#if ENABLE_INNER_LIGHTING > 0
	Out.Eye2 = Eye;
	Out.Normal2 = normalize( mul( normalOrig, (float3x3)WorldMatrix ) );

	if (useSelfshadow)
	{
		// ライト視点によるワールドビュー射影変換
		Out.ZCalcTex2 = mul( posOrig, LightWorldViewProjMatrix );
	}

	Out.Tex.zw = float2(0.5,0.5);
	#if ENABLE_SPHERE_MAP > 0
	if ( useSphereMap ) {
		if ( use_subtexture ) {
			// PMXサブテクスチャ座標
			Out.Tex.zw = Tex2;
		} else {
			// スフィアマップテクスチャ座標
			// スフィアマップテクスチャ座標(外縁が見えやすくなるので少し補正)
			float2 NormalWV = mul( Out.Normal2, (float3x3)ViewMatrix ) * 0.99f;
			Out.Tex.z = NormalWV.x * 0.5f + 0.5f;
			Out.Tex.w = NormalWV.y * -0.5f + 0.5f;
		}
	}
	#endif
	#endif

	return Out;
}


float4 Object_PS(VS_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon, uniform bool useSelfshadow) : COLOR
{
	// 鏡面の裏側にある部位は鏡像表示しない
	clip( IsFace( IN.WPos ) );

	float4 Color = IN.Color;
	float4 ShadowColor = float4(AmbientColor, Color.a);
	#if ENABLE_INNER_LIGHTING > 0
	// パネル内モデルの陰影計算
	float3 N2 = normalize(IN.Normal2);
	float diffuse2 = dot(N2,-LightDirection);
	#else
	float diffuse2 = 1;
	#endif
	if ( !useToon )
	{
		Color.rgb += max(0,diffuse2) * DiffuseColor.rgb;
	}

	if ( useTexture ) {
		float4 TexColor = tex2D( ObjTexSampler, IN.Tex.xy );
		TexColor.rgb = lerp(1, TexColor * TextureMulValue + TextureAddValue, TextureMulValue.a + TextureAddValue.a).rgb;
		Color *= TexColor;
		ShadowColor *= TexColor;
	}

	if ( useSphereMap ) {
		float4 TexColor = tex2D(ObjSphareSampler, IN.Tex.zw);
		TexColor.rgb = lerp(spadd?0:1, TexColor * SphereMulValue + SphereAddValue, SphereMulValue.a + SphereAddValue.a).rgb;
		if(spadd) {
			Color.rgb += TexColor.rgb;
			ShadowColor.rgb += TexColor.rgb;
		} else {
			Color.rgb *= TexColor.rgb;
			ShadowColor.rgb *= TexColor.rgb;
		}
		Color.a *= TexColor.a;
		ShadowColor.a *= TexColor.a;
	}

	#if ENABLE_INNER_LIGHTING > 0
	// パネル内モデルの陰影計算
	float3 H2 = normalize( normalize(IN.Eye2) + -LightDirection );
	Color.rgb += pow( max(0,dot( H2, N2 )), SpecularPower ) * SpecularColor2;
	float comp2 = 1;
	#if ENABLE_SHADOW_MAP > 0
	if (useSelfshadow) comp2 = CalcShadow(IN.ZCalcTex2);
	#endif
	if ( useToon )
	{
		comp2 = min(saturate(diffuse2 * Toon), comp2);
		ShadowColor.rgb *= MaterialToon;
	}
	Color = lerp(ShadowColor, Color, comp2);
	#endif

	// パネルの陰影計算
	float3 N = IN.Normal;
	float diffuse = dot(N,-LightDirection);
	float3 HalfVector = normalize( normalize(IN.Eye) + -LightDirection );
	float3 Specular = pow( max(0,dot( HalfVector, N )), PanelSpecularPower ) * SpecularColor;

	Color.rgb *= PanelLightColor;
	ShadowColor = float4(Color.rgb * PanelShadowColor, Color.a);
	Color.rgb += Specular;

	float comp = 1;
	if (useSelfshadow) comp = CalcShadow(IN.ZCalcTex);
	comp = min(diffuse, comp);

	float4 ans = lerp(ShadowColor, Color, comp);

	return ans;
}



// パネルの描画
VS_OUTPUT Panel_VS(float4 Pos : POSITION, float3 Normal : NORMAL, float2 Tex : TEXCOORD0, float2 Tex2 : TEXCOORD1, uniform bool useSelfshadow, uniform bool isEdge)
{
	VS_OUTPUT Out = (VS_OUTPUT)0;

	float4 posOrig = Pos;
	float3 normalOrig = Normal;

	Pos.xyz = wideflatten(Pos.xyz, Normal, PanelMargin);
	Out.WPos = mul( Pos, WorldMatrix );

	Out.Pos = CalcPanelProjPosition(Pos, PanelDepthOffset);

	Out.Eye = normalize(CameraPosition - mul( Pos, WorldMatrix ).xyz);
	Out.Normal = AdjustPanelNormal(Out.Eye);

	if (useSelfshadow)
	{
		Out.ZCalcTex = mul( Pos, LightWorldViewProjMatrix );
	}

	return Out;
}

float4 Panel_PS(VS_OUTPUT IN, uniform bool useToon, uniform bool useSelfshadow) : COLOR
{
	// 鏡面の裏側にある部位は鏡像表示しない
	clip( IsFace( IN.WPos ) );

	float3 N = IN.Normal;
	float diffuse = max(dot(N,-LightDirection), 0);

	float3 HalfVector = normalize( normalize(IN.Eye) + -LightDirection );
	float3 Specular = pow( max(0,dot( HalfVector, N )), PanelSpecularPower ) * SpecularColor;

	float4 Color = float4(PanelColor * PanelLightColor + Specular, 1);
	float4 ShadowColor = float4(PanelColor * PanelLightColor * PanelShadowColor, Color.a);

	float comp = 1;
	if (useSelfshadow) comp = CalcShadow(IN.ZCalcTex);

	comp = min(diffuse, comp);

	float4 ans = lerp(ShadowColor, Color, comp);
	ans.a = 1; // 抜きは無し

	return ans;
}



#define OBJECT_TEC(name, mmdpass, tex, sphere, toon, selfshadow) \
	technique name < string MMDPass = mmdpass; \
		string Script = \
			"Pass=DrawMask;" \
			"Pass=DrawObject;"; \
		> { \
		pass DrawMask { \
			CullMode = None; \
			VertexShader = compile vs_3_0 Panel_VS(selfshadow, false); \
			PixelShader  = compile ps_3_0 Panel_PS(toon, selfshadow); \
		} \
		pass DrawObject { \
			VertexShader = compile vs_3_0 Object_VS(tex, sphere, toon, selfshadow); \
			PixelShader  = compile ps_3_0 Object_PS(tex, sphere, toon, selfshadow); \
		} \
	}

OBJECT_TEC(MainTec0, "object", use_texture, use_spheremap, use_toon, false)
OBJECT_TEC(MainTecBS0, "object_ss", use_texture, use_spheremap, use_toon, true)


///////////////////////////////////////////////////////////////////////////////////////////////
